- [x] 执行上下文出入栈的整个生命周期行为
- [x] 复习generator 和 iterator
- [x] dom 的 query函数的具体细节



##### 执行上下文

js有一个执行堆栈的概念，栈的每一帧就是执行上下文，栈底是全局上下文，当浏览器窗口关闭时，全局上下文出栈，当进行函数调用时，生成一个函数上下文，上下文的生命周期为上下创建阶段，上下文执行阶段，上下文出栈阶段

1. 上下文创建阶段： 确定了变量对象，作用域链，以及this指向
2. 上下文执行阶段： 全程变量赋值，语句执行等
3. 上下文出栈阶段：函数上下文聪执行堆栈中pop，视情况而定将相关的变量等销毁

###### 变量对象

在上下文的创建阶段，会生成一个叫做变量对象的东西，变量对象在该阶段不可访问

1. 首先将arguments的以key:value的键值对模式写入到变量对象中
2. 将function函数提升，在变量对象中有一个函数指针，指向函数在内存中的具体内容
3. 变量提升，在变量对象中有一个键，值为undefined

###### 作用域链

首先要明确作用域链不同于作用域，作用域链是作用域在js内部的实现，其次，作用域不同于执行上下文，其中，作用域定义的是一套变量或者是函数等标识符的访问规则，是在编译阶段就已经确定下来了，而执行上下文是在函数执行的时候确定的。其中作用域链是一组指针，分别指向当前的执行上下文内的变量对象到全局的上下文变量对象，通过作用域链确定了一整套的变量名以及函数名的访问规则。具体的访问方式为，先从当前上下文的变量对象中搜索相应的标示符，如果找到，就返回相应的键值，如果没有找到，则沿着上层上下文的变量对象寻找，如果在最终的全局上下文内都没有找到相应的标示，则报错。



###### this指向

在之前已经总结过了，this是在函数调用时（上下文创建时） 绑定的，正常情况下，this指向可以分为三种

1. 如果函数调用者是对象，那么就指向那个对象

2. 如果在全局调用，在严格模式下指向undefined，兼容模式下指向window

3. 如果使用 new + 构造函数的方法来构造一个对象实例，那么在构造函数中的this指向新创建的那一个对象

4. 函数的this指向可以认为的动态改变（可以通过apply，call，或者是bind方法显示的传入一个对象，从而将

   this指向该对象

###### 活动对象

活动对象和变量对象其实是同一个东西，只是一个对象在执行上下文的不同阶段的不同表现，当执行上下文从创建阶段进入执行阶段，那么相应的，变量对象也转变为活动对象，可以访问或者是修改变量对象中的相应键值。

###### 内存销毁

js不需要手动的通过某种方式去销毁内存，相应的，js会自动的通过某种机制定时的去销毁内存，常见的内存释放有标记释放，计数释放等，标记释放是指如果变量对象所在的上下文出栈，则将相关的变量打上变量出栈的标记，

计数释放是每对变量引用一次，则对该变量做一次计数操作，当垃圾回收的时候，判断当前的变量的引用数是否为0，如果引用数为0，则将该变量从内存中销毁。





##### DOM 操作

1. Document.querySelector('xxxx') 返回符合条件的第一个元素
2. Document.querySelectorAll('xxxx') 返回符合条件的所有元素组成的数组




##### generator 以及 iterator

只要数据结构部署了iterator的接口，那么这个数据结构就可以被`...` 或者是`for of` 识别，并将其每个数据提取出来，两者之前的关系， generator返回的就是一个iterator对象，所以可以使用generator快速的构建一个数据结构的迭代器，另外，只要数据结构有[Symbol.iterator]属性，那么这个数据结构就可以被分隔符所获取。